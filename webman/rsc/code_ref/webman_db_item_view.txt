#_title_
webman_db_item_view
#_end_

#_des_
### Component-type module that provides basic and simple database table items  
### view/listing.
#_end_

#_dep_
### <b>Webman-framework's Core Modules:</b><br />
### <ul>
### <li>DBI_HTML_Map (Composition)</li>
### </ul>
### <br />
### <b>Webman-framework's Component-type Modules:</b><br />
### <ul>
### <li>CGI_Component::webman_CGI_component (Inheritance)</li>
### <li>webman_link_path_generator (Composition)</li>
### </ul>
#_end_

#_sec_ ------------------------------------------------------------------------
#_doc_
### <b>1. View Template</b>
### <p />
### The DYNAMIC_CONTENT template-element (line 4) named <c>link_path</c> will 
### be processed by <c>webman_link_path_generator</c> module inside  
### <c>process_DYNAMIC</c> hook function. It's used as place-holder to render 
### current application's link path when webman_db_item_view module is 
### called.
### <p />
### The main part of the view template where database table items will be 
### rendered is the unnamed DBHTML template-element (line 16-21) contains word 
### patterns <c>$db_<i>field_name_1</i>_</c> till 
### <c>$db_<i>field_name_n</i>_</c>. The form of word patterns used are 
### following the requirements imposed by DBI_HTML_Map core module for the 
### purpose of mapping database table field values into the template-element. 
### This unnamed DBHTML template-element will be passed to 
### <c>process_DBHTML</c> hook function before manipulated DBI_HTML_Map 
### module. 
### 
#_end_
#_code_num_ 4-4:#ffdddd,16-21:#ddffdd 1
<html>
<body>
<!-- start_view_ //-->
<!-- dynamic_content_ name=link_path //--> &gt; List Title
<p />

<table border="1">
  <tr>
    <th>Num.</th>
    <th>field_caption_1</th>
    <th>field_caption_2</th>
    <th>field_caption_n</th>
  </tr>

  <!-- start_dbhtml_ //-->
  <tr>
    <td align="right">$num_.</td>
    <td>$db_field_name_1_</td>
    ...
    <td>$db_field_name_n_</td>
  </tr>
  <!-- end_dbhtml_ //-->
</table>

<!-- end_view_ //-->
</body>
</html>
#_end_

#_sec_ ------------------------------------------------------------------------
#_doc_
### <b>2. Instantiation and Basic Parameter Setting</b>
### <p />
### Database table items to be viewed/listed are retrieved via standard SQL's 
### <c>select</c> string command (line 9).
#_end_
#_code_num_ 9-9:#ffdddd 1
my $component = new webman_db_item_view;

$component->set_CGI($cgi);
$component->set_DBI_Conn($db_conn);

### Option to debug SQL satement generated by the module.
#$component->set_SQL_Debug(1); 

$component->set_SQL("select * from ... where ... order by ...");

$component->set_Template_Default($template_file); 
 
#_end_

#_sec_ ------------------------------------------------------------------------
#_doc_
### <b>3. Component-type Generic Function Calls</b>
### <p />
#_end_
#_code_num_ 0 13
if ($component->authenticate) {
    $component->run_Task;
    $component->process_Content;
    $component->end_Task;
}

my $content = $component->get_Content;
#_end_

#_sec_ ------------------------------------------------------------------------
#_doc_
### <b>4. Child Module for Customization</b>
### <p />
### The possible customization tasks are to manipulate the DBHTML 
### template-element content (lines 64-65) before it being used and processed 
### as place-holder for database items list (line 70) and programmatically 
### modify the SQL's <c>select</c> string command (line 83) to support more 
### complex database query logic.
#_end_
#_code_num_ 64-65:#ffdddd,70-70:#ddffdd,83-83:#ffddff 1
package <trp><i>child_module_name</i></trp>;

use webman_db_item_view;

@ISA=("webman_db_item_view");

sub new {
    my $class = shift;
    
    my $this = $class->SUPER::new();
    
    #$this->set_Debug_Mode(1, 1);
    
    bless $this, $class;
    
    return $this;
}

sub get_Name {
    my $this = shift @_;
    
    return __PACKAGE__;
}

sub get_Name_Full {
    my $this = shift @_;
    
    return $this->SUPER::get_Name_Full . "::" . __PACKAGE__;
}

sub run_Task {
    my $this = shift @_;
    
    my $cgi = $this->get_CGI;
    my $dbu = $this->get_DBU;
    my $db_conn = $this->get_DB_Conn;
    
    my $login_name = $this->get_User_Login;
    my @groups = $this->get_User_Groups;
    
    my $match_group = $this->match_Group($group_name_, @groups);
    
    $this->SUPER::run_Task;
}

sub process_DBHTML {
    my $this = shift @_;
    my $te = shift @_;

    my $cgi = $this->get_CGI;
    my $dbu = $this->get_DBU;
    my $db_conn = $this->get_DB_Conn;
    
    my $login_name = $this->get_User_Login;
    my @groups = $this->get_User_Groups;
    
    my $match_group = $this->match_Group($group_name_, @groups);
    
    my $te_content = $te->get_Content;
    my $te_type_num = $te->get_Type_Num;
    
    ### It's possible to first manipulate DBHTML template-element content  
    ### before it being processed by DBI_HTML_Map core module. 
    #$te_content = ...;
    #$te->set_Content = $te_content;
    
    ### Call back the overriden base class function that will do the real 
    ### implementations of manipulating DBHTML template-element content 
    ### using DBI_HTML_Map core module.
    $this->SUPER::process_DBHTML($te);
}

sub customize_SQL { 
    my $this = shift @_;

    my $cgi = $this->get_CGI;
    my $dbu = $this->get_DBU;
    my $db_conn = $this->get_DB_Conn;
    
    my $sql = $this->{sql};
    
    ### Next is to customize the $sql string.
    #$sql = ...;
    
    return $sql;
}

1;
#_end_
#_doc_
<a href="./txtsrc/webman_db_item_view_child.txt">Get code...</href>
#_end_